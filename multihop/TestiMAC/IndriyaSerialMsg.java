/**
 * This class is automatically generated by mig. DO NOT EDIT THIS FILE.
 * This class implements a Java interface to the 'IndriyaSerialMsg'
 * message type.
 */

public class IndriyaSerialMsg extends net.tinyos.message.Message {

    /** The default size of this message type in bytes. */
    public static final int DEFAULT_MESSAGE_SIZE = 110;

    /** The Active Message type associated with this message. */
    public static final int AM_TYPE = -1;

    /** Create a new IndriyaSerialMsg of size 110. */
    public IndriyaSerialMsg() {
        super(DEFAULT_MESSAGE_SIZE);
        amTypeSet(AM_TYPE);
    }

    /** Create a new IndriyaSerialMsg of the given data_length. */
    public IndriyaSerialMsg(int data_length) {
        super(data_length);
        amTypeSet(AM_TYPE);
    }

    /**
     * Create a new IndriyaSerialMsg with the given data_length
     * and base offset.
     */
    public IndriyaSerialMsg(int data_length, int base_offset) {
        super(data_length, base_offset);
        amTypeSet(AM_TYPE);
    }

    /**
     * Create a new IndriyaSerialMsg using the given byte array
     * as backing store.
     */
    public IndriyaSerialMsg(byte[] data) {
        super(data);
        amTypeSet(AM_TYPE);
    }

    /**
     * Create a new IndriyaSerialMsg using the given byte array
     * as backing store, with the given base offset.
     */
    public IndriyaSerialMsg(byte[] data, int base_offset) {
        super(data, base_offset);
        amTypeSet(AM_TYPE);
    }

    /**
     * Create a new IndriyaSerialMsg using the given byte array
     * as backing store, with the given base offset and data length.
     */
    public IndriyaSerialMsg(byte[] data, int base_offset, int data_length) {
        super(data, base_offset, data_length);
        amTypeSet(AM_TYPE);
    }

    /**
     * Create a new IndriyaSerialMsg embedded in the given message
     * at the given base offset.
     */
    public IndriyaSerialMsg(net.tinyos.message.Message msg, int base_offset) {
        super(msg, base_offset, DEFAULT_MESSAGE_SIZE);
        amTypeSet(AM_TYPE);
    }

    /**
     * Create a new IndriyaSerialMsg embedded in the given message
     * at the given base offset and length.
     */
    public IndriyaSerialMsg(net.tinyos.message.Message msg, int base_offset, int data_length) {
        super(msg, base_offset, data_length);
        amTypeSet(AM_TYPE);
    }

    /**
    /* Return a String representation of this message. Includes the
     * message type name and the non-indexed field values.
     */
    public String toString() {
      String s = "Message <IndriyaSerialMsg> \n";
      try {
        s += "  [m0.type=0x"+Long.toHexString(get_m0_type())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m0.nodeId=0x"+Long.toHexString(get_m0_nodeId())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m0.sourceId=0x"+Long.toHexString(get_m0_sourceId())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m0.seq=0x"+Long.toHexString(get_m0_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m0.last_hop=0x"+Long.toHexString(get_m0_last_hop())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m0.last_hop_ntw_seq=0x"+Long.toHexString(get_m0_last_hop_ntw_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m0.last_hop_seq=0x"+Long.toHexString(get_m0_last_hop_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m0.local_ntw_seq=0x"+Long.toHexString(get_m0_local_ntw_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m0.local_seq=0x"+Long.toHexString(get_m0_local_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m0.timestamp=0x"+Long.toHexString(get_m0_timestamp())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m0.seqno=0x"+Long.toHexString(get_m0_seqno())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m1.type=0x"+Long.toHexString(get_m1_type())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m1.nodeId=0x"+Long.toHexString(get_m1_nodeId())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m1.sourceId=0x"+Long.toHexString(get_m1_sourceId())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m1.seq=0x"+Long.toHexString(get_m1_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m1.last_hop=0x"+Long.toHexString(get_m1_last_hop())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m1.last_hop_ntw_seq=0x"+Long.toHexString(get_m1_last_hop_ntw_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m1.last_hop_seq=0x"+Long.toHexString(get_m1_last_hop_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m1.local_ntw_seq=0x"+Long.toHexString(get_m1_local_ntw_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m1.local_seq=0x"+Long.toHexString(get_m1_local_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m1.timestamp=0x"+Long.toHexString(get_m1_timestamp())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m1.seqno=0x"+Long.toHexString(get_m1_seqno())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m2.type=0x"+Long.toHexString(get_m2_type())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m2.nodeId=0x"+Long.toHexString(get_m2_nodeId())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m2.sourceId=0x"+Long.toHexString(get_m2_sourceId())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m2.seq=0x"+Long.toHexString(get_m2_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m2.last_hop=0x"+Long.toHexString(get_m2_last_hop())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m2.last_hop_ntw_seq=0x"+Long.toHexString(get_m2_last_hop_ntw_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m2.last_hop_seq=0x"+Long.toHexString(get_m2_last_hop_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m2.local_ntw_seq=0x"+Long.toHexString(get_m2_local_ntw_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m2.local_seq=0x"+Long.toHexString(get_m2_local_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m2.timestamp=0x"+Long.toHexString(get_m2_timestamp())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m2.seqno=0x"+Long.toHexString(get_m2_seqno())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m3.type=0x"+Long.toHexString(get_m3_type())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m3.nodeId=0x"+Long.toHexString(get_m3_nodeId())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m3.sourceId=0x"+Long.toHexString(get_m3_sourceId())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m3.seq=0x"+Long.toHexString(get_m3_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m3.last_hop=0x"+Long.toHexString(get_m3_last_hop())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m3.last_hop_ntw_seq=0x"+Long.toHexString(get_m3_last_hop_ntw_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m3.last_hop_seq=0x"+Long.toHexString(get_m3_last_hop_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m3.local_ntw_seq=0x"+Long.toHexString(get_m3_local_ntw_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m3.local_seq=0x"+Long.toHexString(get_m3_local_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m3.timestamp=0x"+Long.toHexString(get_m3_timestamp())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m3.seqno=0x"+Long.toHexString(get_m3_seqno())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m4.type=0x"+Long.toHexString(get_m4_type())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m4.nodeId=0x"+Long.toHexString(get_m4_nodeId())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m4.sourceId=0x"+Long.toHexString(get_m4_sourceId())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m4.seq=0x"+Long.toHexString(get_m4_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m4.last_hop=0x"+Long.toHexString(get_m4_last_hop())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m4.last_hop_ntw_seq=0x"+Long.toHexString(get_m4_last_hop_ntw_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m4.last_hop_seq=0x"+Long.toHexString(get_m4_last_hop_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m4.local_ntw_seq=0x"+Long.toHexString(get_m4_local_ntw_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m4.local_seq=0x"+Long.toHexString(get_m4_local_seq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m4.timestamp=0x"+Long.toHexString(get_m4_timestamp())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [m4.seqno=0x"+Long.toHexString(get_m4_seqno())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      return s;
    }

    // Message-type-specific access methods appear below.

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m0.type
    //   Field type: short
    //   Offset (bits): 0
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm0.type' is signed (false).
     */
    public static boolean isSigned_m0_type() {
        return false;
    }

    /**
     * Return whether the field 'm0.type' is an array (false).
     */
    public static boolean isArray_m0_type() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm0.type'
     */
    public static int offset_m0_type() {
        return (0 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm0.type'
     */
    public static int offsetBits_m0_type() {
        return 0;
    }

    /**
     * Return the value (as a short) of the field 'm0.type'
     */
    public short get_m0_type() {
        return (short)getUIntBEElement(offsetBits_m0_type(), 8);
    }

    /**
     * Set the value of the field 'm0.type'
     */
    public void set_m0_type(short value) {
        setUIntBEElement(offsetBits_m0_type(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm0.type'
     */
    public static int size_m0_type() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm0.type'
     */
    public static int sizeBits_m0_type() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m0.nodeId
    //   Field type: short
    //   Offset (bits): 8
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm0.nodeId' is signed (false).
     */
    public static boolean isSigned_m0_nodeId() {
        return false;
    }

    /**
     * Return whether the field 'm0.nodeId' is an array (false).
     */
    public static boolean isArray_m0_nodeId() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm0.nodeId'
     */
    public static int offset_m0_nodeId() {
        return (8 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm0.nodeId'
     */
    public static int offsetBits_m0_nodeId() {
        return 8;
    }

    /**
     * Return the value (as a short) of the field 'm0.nodeId'
     */
    public short get_m0_nodeId() {
        return (short)getUIntBEElement(offsetBits_m0_nodeId(), 8);
    }

    /**
     * Set the value of the field 'm0.nodeId'
     */
    public void set_m0_nodeId(short value) {
        setUIntBEElement(offsetBits_m0_nodeId(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm0.nodeId'
     */
    public static int size_m0_nodeId() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm0.nodeId'
     */
    public static int sizeBits_m0_nodeId() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m0.sourceId
    //   Field type: short
    //   Offset (bits): 16
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm0.sourceId' is signed (false).
     */
    public static boolean isSigned_m0_sourceId() {
        return false;
    }

    /**
     * Return whether the field 'm0.sourceId' is an array (false).
     */
    public static boolean isArray_m0_sourceId() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm0.sourceId'
     */
    public static int offset_m0_sourceId() {
        return (16 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm0.sourceId'
     */
    public static int offsetBits_m0_sourceId() {
        return 16;
    }

    /**
     * Return the value (as a short) of the field 'm0.sourceId'
     */
    public short get_m0_sourceId() {
        return (short)getUIntBEElement(offsetBits_m0_sourceId(), 8);
    }

    /**
     * Set the value of the field 'm0.sourceId'
     */
    public void set_m0_sourceId(short value) {
        setUIntBEElement(offsetBits_m0_sourceId(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm0.sourceId'
     */
    public static int size_m0_sourceId() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm0.sourceId'
     */
    public static int sizeBits_m0_sourceId() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m0.seq
    //   Field type: int
    //   Offset (bits): 24
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm0.seq' is signed (false).
     */
    public static boolean isSigned_m0_seq() {
        return false;
    }

    /**
     * Return whether the field 'm0.seq' is an array (false).
     */
    public static boolean isArray_m0_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm0.seq'
     */
    public static int offset_m0_seq() {
        return (24 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm0.seq'
     */
    public static int offsetBits_m0_seq() {
        return 24;
    }

    /**
     * Return the value (as a int) of the field 'm0.seq'
     */
    public int get_m0_seq() {
        return (int)getUIntBEElement(offsetBits_m0_seq(), 16);
    }

    /**
     * Set the value of the field 'm0.seq'
     */
    public void set_m0_seq(int value) {
        setUIntBEElement(offsetBits_m0_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm0.seq'
     */
    public static int size_m0_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm0.seq'
     */
    public static int sizeBits_m0_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m0.last_hop
    //   Field type: short
    //   Offset (bits): 40
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm0.last_hop' is signed (false).
     */
    public static boolean isSigned_m0_last_hop() {
        return false;
    }

    /**
     * Return whether the field 'm0.last_hop' is an array (false).
     */
    public static boolean isArray_m0_last_hop() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm0.last_hop'
     */
    public static int offset_m0_last_hop() {
        return (40 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm0.last_hop'
     */
    public static int offsetBits_m0_last_hop() {
        return 40;
    }

    /**
     * Return the value (as a short) of the field 'm0.last_hop'
     */
    public short get_m0_last_hop() {
        return (short)getUIntBEElement(offsetBits_m0_last_hop(), 8);
    }

    /**
     * Set the value of the field 'm0.last_hop'
     */
    public void set_m0_last_hop(short value) {
        setUIntBEElement(offsetBits_m0_last_hop(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm0.last_hop'
     */
    public static int size_m0_last_hop() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm0.last_hop'
     */
    public static int sizeBits_m0_last_hop() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m0.last_hop_ntw_seq
    //   Field type: int
    //   Offset (bits): 48
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm0.last_hop_ntw_seq' is signed (false).
     */
    public static boolean isSigned_m0_last_hop_ntw_seq() {
        return false;
    }

    /**
     * Return whether the field 'm0.last_hop_ntw_seq' is an array (false).
     */
    public static boolean isArray_m0_last_hop_ntw_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm0.last_hop_ntw_seq'
     */
    public static int offset_m0_last_hop_ntw_seq() {
        return (48 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm0.last_hop_ntw_seq'
     */
    public static int offsetBits_m0_last_hop_ntw_seq() {
        return 48;
    }

    /**
     * Return the value (as a int) of the field 'm0.last_hop_ntw_seq'
     */
    public int get_m0_last_hop_ntw_seq() {
        return (int)getUIntBEElement(offsetBits_m0_last_hop_ntw_seq(), 16);
    }

    /**
     * Set the value of the field 'm0.last_hop_ntw_seq'
     */
    public void set_m0_last_hop_ntw_seq(int value) {
        setUIntBEElement(offsetBits_m0_last_hop_ntw_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm0.last_hop_ntw_seq'
     */
    public static int size_m0_last_hop_ntw_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm0.last_hop_ntw_seq'
     */
    public static int sizeBits_m0_last_hop_ntw_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m0.last_hop_seq
    //   Field type: int
    //   Offset (bits): 64
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm0.last_hop_seq' is signed (false).
     */
    public static boolean isSigned_m0_last_hop_seq() {
        return false;
    }

    /**
     * Return whether the field 'm0.last_hop_seq' is an array (false).
     */
    public static boolean isArray_m0_last_hop_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm0.last_hop_seq'
     */
    public static int offset_m0_last_hop_seq() {
        return (64 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm0.last_hop_seq'
     */
    public static int offsetBits_m0_last_hop_seq() {
        return 64;
    }

    /**
     * Return the value (as a int) of the field 'm0.last_hop_seq'
     */
    public int get_m0_last_hop_seq() {
        return (int)getUIntBEElement(offsetBits_m0_last_hop_seq(), 16);
    }

    /**
     * Set the value of the field 'm0.last_hop_seq'
     */
    public void set_m0_last_hop_seq(int value) {
        setUIntBEElement(offsetBits_m0_last_hop_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm0.last_hop_seq'
     */
    public static int size_m0_last_hop_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm0.last_hop_seq'
     */
    public static int sizeBits_m0_last_hop_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m0.local_ntw_seq
    //   Field type: int
    //   Offset (bits): 80
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm0.local_ntw_seq' is signed (false).
     */
    public static boolean isSigned_m0_local_ntw_seq() {
        return false;
    }

    /**
     * Return whether the field 'm0.local_ntw_seq' is an array (false).
     */
    public static boolean isArray_m0_local_ntw_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm0.local_ntw_seq'
     */
    public static int offset_m0_local_ntw_seq() {
        return (80 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm0.local_ntw_seq'
     */
    public static int offsetBits_m0_local_ntw_seq() {
        return 80;
    }

    /**
     * Return the value (as a int) of the field 'm0.local_ntw_seq'
     */
    public int get_m0_local_ntw_seq() {
        return (int)getUIntBEElement(offsetBits_m0_local_ntw_seq(), 16);
    }

    /**
     * Set the value of the field 'm0.local_ntw_seq'
     */
    public void set_m0_local_ntw_seq(int value) {
        setUIntBEElement(offsetBits_m0_local_ntw_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm0.local_ntw_seq'
     */
    public static int size_m0_local_ntw_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm0.local_ntw_seq'
     */
    public static int sizeBits_m0_local_ntw_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m0.local_seq
    //   Field type: int
    //   Offset (bits): 96
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm0.local_seq' is signed (false).
     */
    public static boolean isSigned_m0_local_seq() {
        return false;
    }

    /**
     * Return whether the field 'm0.local_seq' is an array (false).
     */
    public static boolean isArray_m0_local_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm0.local_seq'
     */
    public static int offset_m0_local_seq() {
        return (96 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm0.local_seq'
     */
    public static int offsetBits_m0_local_seq() {
        return 96;
    }

    /**
     * Return the value (as a int) of the field 'm0.local_seq'
     */
    public int get_m0_local_seq() {
        return (int)getUIntBEElement(offsetBits_m0_local_seq(), 16);
    }

    /**
     * Set the value of the field 'm0.local_seq'
     */
    public void set_m0_local_seq(int value) {
        setUIntBEElement(offsetBits_m0_local_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm0.local_seq'
     */
    public static int size_m0_local_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm0.local_seq'
     */
    public static int sizeBits_m0_local_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m0.timestamp
    //   Field type: long
    //   Offset (bits): 112
    //   Size (bits): 32
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm0.timestamp' is signed (false).
     */
    public static boolean isSigned_m0_timestamp() {
        return false;
    }

    /**
     * Return whether the field 'm0.timestamp' is an array (false).
     */
    public static boolean isArray_m0_timestamp() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm0.timestamp'
     */
    public static int offset_m0_timestamp() {
        return (112 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm0.timestamp'
     */
    public static int offsetBits_m0_timestamp() {
        return 112;
    }

    /**
     * Return the value (as a long) of the field 'm0.timestamp'
     */
    public long get_m0_timestamp() {
        return (long)getUIntBEElement(offsetBits_m0_timestamp(), 32);
    }

    /**
     * Set the value of the field 'm0.timestamp'
     */
    public void set_m0_timestamp(long value) {
        setUIntBEElement(offsetBits_m0_timestamp(), 32, value);
    }

    /**
     * Return the size, in bytes, of the field 'm0.timestamp'
     */
    public static int size_m0_timestamp() {
        return (32 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm0.timestamp'
     */
    public static int sizeBits_m0_timestamp() {
        return 32;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m0.seqno
    //   Field type: long
    //   Offset (bits): 144
    //   Size (bits): 32
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm0.seqno' is signed (false).
     */
    public static boolean isSigned_m0_seqno() {
        return false;
    }

    /**
     * Return whether the field 'm0.seqno' is an array (false).
     */
    public static boolean isArray_m0_seqno() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm0.seqno'
     */
    public static int offset_m0_seqno() {
        return (144 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm0.seqno'
     */
    public static int offsetBits_m0_seqno() {
        return 144;
    }

    /**
     * Return the value (as a long) of the field 'm0.seqno'
     */
    public long get_m0_seqno() {
        return (long)getUIntBEElement(offsetBits_m0_seqno(), 32);
    }

    /**
     * Set the value of the field 'm0.seqno'
     */
    public void set_m0_seqno(long value) {
        setUIntBEElement(offsetBits_m0_seqno(), 32, value);
    }

    /**
     * Return the size, in bytes, of the field 'm0.seqno'
     */
    public static int size_m0_seqno() {
        return (32 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm0.seqno'
     */
    public static int sizeBits_m0_seqno() {
        return 32;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m1.type
    //   Field type: short
    //   Offset (bits): 176
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm1.type' is signed (false).
     */
    public static boolean isSigned_m1_type() {
        return false;
    }

    /**
     * Return whether the field 'm1.type' is an array (false).
     */
    public static boolean isArray_m1_type() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm1.type'
     */
    public static int offset_m1_type() {
        return (176 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm1.type'
     */
    public static int offsetBits_m1_type() {
        return 176;
    }

    /**
     * Return the value (as a short) of the field 'm1.type'
     */
    public short get_m1_type() {
        return (short)getUIntBEElement(offsetBits_m1_type(), 8);
    }

    /**
     * Set the value of the field 'm1.type'
     */
    public void set_m1_type(short value) {
        setUIntBEElement(offsetBits_m1_type(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm1.type'
     */
    public static int size_m1_type() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm1.type'
     */
    public static int sizeBits_m1_type() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m1.nodeId
    //   Field type: short
    //   Offset (bits): 184
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm1.nodeId' is signed (false).
     */
    public static boolean isSigned_m1_nodeId() {
        return false;
    }

    /**
     * Return whether the field 'm1.nodeId' is an array (false).
     */
    public static boolean isArray_m1_nodeId() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm1.nodeId'
     */
    public static int offset_m1_nodeId() {
        return (184 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm1.nodeId'
     */
    public static int offsetBits_m1_nodeId() {
        return 184;
    }

    /**
     * Return the value (as a short) of the field 'm1.nodeId'
     */
    public short get_m1_nodeId() {
        return (short)getUIntBEElement(offsetBits_m1_nodeId(), 8);
    }

    /**
     * Set the value of the field 'm1.nodeId'
     */
    public void set_m1_nodeId(short value) {
        setUIntBEElement(offsetBits_m1_nodeId(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm1.nodeId'
     */
    public static int size_m1_nodeId() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm1.nodeId'
     */
    public static int sizeBits_m1_nodeId() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m1.sourceId
    //   Field type: short
    //   Offset (bits): 192
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm1.sourceId' is signed (false).
     */
    public static boolean isSigned_m1_sourceId() {
        return false;
    }

    /**
     * Return whether the field 'm1.sourceId' is an array (false).
     */
    public static boolean isArray_m1_sourceId() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm1.sourceId'
     */
    public static int offset_m1_sourceId() {
        return (192 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm1.sourceId'
     */
    public static int offsetBits_m1_sourceId() {
        return 192;
    }

    /**
     * Return the value (as a short) of the field 'm1.sourceId'
     */
    public short get_m1_sourceId() {
        return (short)getUIntBEElement(offsetBits_m1_sourceId(), 8);
    }

    /**
     * Set the value of the field 'm1.sourceId'
     */
    public void set_m1_sourceId(short value) {
        setUIntBEElement(offsetBits_m1_sourceId(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm1.sourceId'
     */
    public static int size_m1_sourceId() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm1.sourceId'
     */
    public static int sizeBits_m1_sourceId() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m1.seq
    //   Field type: int
    //   Offset (bits): 200
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm1.seq' is signed (false).
     */
    public static boolean isSigned_m1_seq() {
        return false;
    }

    /**
     * Return whether the field 'm1.seq' is an array (false).
     */
    public static boolean isArray_m1_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm1.seq'
     */
    public static int offset_m1_seq() {
        return (200 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm1.seq'
     */
    public static int offsetBits_m1_seq() {
        return 200;
    }

    /**
     * Return the value (as a int) of the field 'm1.seq'
     */
    public int get_m1_seq() {
        return (int)getUIntBEElement(offsetBits_m1_seq(), 16);
    }

    /**
     * Set the value of the field 'm1.seq'
     */
    public void set_m1_seq(int value) {
        setUIntBEElement(offsetBits_m1_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm1.seq'
     */
    public static int size_m1_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm1.seq'
     */
    public static int sizeBits_m1_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m1.last_hop
    //   Field type: short
    //   Offset (bits): 216
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm1.last_hop' is signed (false).
     */
    public static boolean isSigned_m1_last_hop() {
        return false;
    }

    /**
     * Return whether the field 'm1.last_hop' is an array (false).
     */
    public static boolean isArray_m1_last_hop() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm1.last_hop'
     */
    public static int offset_m1_last_hop() {
        return (216 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm1.last_hop'
     */
    public static int offsetBits_m1_last_hop() {
        return 216;
    }

    /**
     * Return the value (as a short) of the field 'm1.last_hop'
     */
    public short get_m1_last_hop() {
        return (short)getUIntBEElement(offsetBits_m1_last_hop(), 8);
    }

    /**
     * Set the value of the field 'm1.last_hop'
     */
    public void set_m1_last_hop(short value) {
        setUIntBEElement(offsetBits_m1_last_hop(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm1.last_hop'
     */
    public static int size_m1_last_hop() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm1.last_hop'
     */
    public static int sizeBits_m1_last_hop() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m1.last_hop_ntw_seq
    //   Field type: int
    //   Offset (bits): 224
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm1.last_hop_ntw_seq' is signed (false).
     */
    public static boolean isSigned_m1_last_hop_ntw_seq() {
        return false;
    }

    /**
     * Return whether the field 'm1.last_hop_ntw_seq' is an array (false).
     */
    public static boolean isArray_m1_last_hop_ntw_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm1.last_hop_ntw_seq'
     */
    public static int offset_m1_last_hop_ntw_seq() {
        return (224 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm1.last_hop_ntw_seq'
     */
    public static int offsetBits_m1_last_hop_ntw_seq() {
        return 224;
    }

    /**
     * Return the value (as a int) of the field 'm1.last_hop_ntw_seq'
     */
    public int get_m1_last_hop_ntw_seq() {
        return (int)getUIntBEElement(offsetBits_m1_last_hop_ntw_seq(), 16);
    }

    /**
     * Set the value of the field 'm1.last_hop_ntw_seq'
     */
    public void set_m1_last_hop_ntw_seq(int value) {
        setUIntBEElement(offsetBits_m1_last_hop_ntw_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm1.last_hop_ntw_seq'
     */
    public static int size_m1_last_hop_ntw_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm1.last_hop_ntw_seq'
     */
    public static int sizeBits_m1_last_hop_ntw_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m1.last_hop_seq
    //   Field type: int
    //   Offset (bits): 240
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm1.last_hop_seq' is signed (false).
     */
    public static boolean isSigned_m1_last_hop_seq() {
        return false;
    }

    /**
     * Return whether the field 'm1.last_hop_seq' is an array (false).
     */
    public static boolean isArray_m1_last_hop_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm1.last_hop_seq'
     */
    public static int offset_m1_last_hop_seq() {
        return (240 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm1.last_hop_seq'
     */
    public static int offsetBits_m1_last_hop_seq() {
        return 240;
    }

    /**
     * Return the value (as a int) of the field 'm1.last_hop_seq'
     */
    public int get_m1_last_hop_seq() {
        return (int)getUIntBEElement(offsetBits_m1_last_hop_seq(), 16);
    }

    /**
     * Set the value of the field 'm1.last_hop_seq'
     */
    public void set_m1_last_hop_seq(int value) {
        setUIntBEElement(offsetBits_m1_last_hop_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm1.last_hop_seq'
     */
    public static int size_m1_last_hop_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm1.last_hop_seq'
     */
    public static int sizeBits_m1_last_hop_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m1.local_ntw_seq
    //   Field type: int
    //   Offset (bits): 256
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm1.local_ntw_seq' is signed (false).
     */
    public static boolean isSigned_m1_local_ntw_seq() {
        return false;
    }

    /**
     * Return whether the field 'm1.local_ntw_seq' is an array (false).
     */
    public static boolean isArray_m1_local_ntw_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm1.local_ntw_seq'
     */
    public static int offset_m1_local_ntw_seq() {
        return (256 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm1.local_ntw_seq'
     */
    public static int offsetBits_m1_local_ntw_seq() {
        return 256;
    }

    /**
     * Return the value (as a int) of the field 'm1.local_ntw_seq'
     */
    public int get_m1_local_ntw_seq() {
        return (int)getUIntBEElement(offsetBits_m1_local_ntw_seq(), 16);
    }

    /**
     * Set the value of the field 'm1.local_ntw_seq'
     */
    public void set_m1_local_ntw_seq(int value) {
        setUIntBEElement(offsetBits_m1_local_ntw_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm1.local_ntw_seq'
     */
    public static int size_m1_local_ntw_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm1.local_ntw_seq'
     */
    public static int sizeBits_m1_local_ntw_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m1.local_seq
    //   Field type: int
    //   Offset (bits): 272
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm1.local_seq' is signed (false).
     */
    public static boolean isSigned_m1_local_seq() {
        return false;
    }

    /**
     * Return whether the field 'm1.local_seq' is an array (false).
     */
    public static boolean isArray_m1_local_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm1.local_seq'
     */
    public static int offset_m1_local_seq() {
        return (272 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm1.local_seq'
     */
    public static int offsetBits_m1_local_seq() {
        return 272;
    }

    /**
     * Return the value (as a int) of the field 'm1.local_seq'
     */
    public int get_m1_local_seq() {
        return (int)getUIntBEElement(offsetBits_m1_local_seq(), 16);
    }

    /**
     * Set the value of the field 'm1.local_seq'
     */
    public void set_m1_local_seq(int value) {
        setUIntBEElement(offsetBits_m1_local_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm1.local_seq'
     */
    public static int size_m1_local_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm1.local_seq'
     */
    public static int sizeBits_m1_local_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m1.timestamp
    //   Field type: long
    //   Offset (bits): 288
    //   Size (bits): 32
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm1.timestamp' is signed (false).
     */
    public static boolean isSigned_m1_timestamp() {
        return false;
    }

    /**
     * Return whether the field 'm1.timestamp' is an array (false).
     */
    public static boolean isArray_m1_timestamp() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm1.timestamp'
     */
    public static int offset_m1_timestamp() {
        return (288 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm1.timestamp'
     */
    public static int offsetBits_m1_timestamp() {
        return 288;
    }

    /**
     * Return the value (as a long) of the field 'm1.timestamp'
     */
    public long get_m1_timestamp() {
        return (long)getUIntBEElement(offsetBits_m1_timestamp(), 32);
    }

    /**
     * Set the value of the field 'm1.timestamp'
     */
    public void set_m1_timestamp(long value) {
        setUIntBEElement(offsetBits_m1_timestamp(), 32, value);
    }

    /**
     * Return the size, in bytes, of the field 'm1.timestamp'
     */
    public static int size_m1_timestamp() {
        return (32 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm1.timestamp'
     */
    public static int sizeBits_m1_timestamp() {
        return 32;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m1.seqno
    //   Field type: long
    //   Offset (bits): 320
    //   Size (bits): 32
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm1.seqno' is signed (false).
     */
    public static boolean isSigned_m1_seqno() {
        return false;
    }

    /**
     * Return whether the field 'm1.seqno' is an array (false).
     */
    public static boolean isArray_m1_seqno() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm1.seqno'
     */
    public static int offset_m1_seqno() {
        return (320 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm1.seqno'
     */
    public static int offsetBits_m1_seqno() {
        return 320;
    }

    /**
     * Return the value (as a long) of the field 'm1.seqno'
     */
    public long get_m1_seqno() {
        return (long)getUIntBEElement(offsetBits_m1_seqno(), 32);
    }

    /**
     * Set the value of the field 'm1.seqno'
     */
    public void set_m1_seqno(long value) {
        setUIntBEElement(offsetBits_m1_seqno(), 32, value);
    }

    /**
     * Return the size, in bytes, of the field 'm1.seqno'
     */
    public static int size_m1_seqno() {
        return (32 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm1.seqno'
     */
    public static int sizeBits_m1_seqno() {
        return 32;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m2.type
    //   Field type: short
    //   Offset (bits): 352
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm2.type' is signed (false).
     */
    public static boolean isSigned_m2_type() {
        return false;
    }

    /**
     * Return whether the field 'm2.type' is an array (false).
     */
    public static boolean isArray_m2_type() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm2.type'
     */
    public static int offset_m2_type() {
        return (352 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm2.type'
     */
    public static int offsetBits_m2_type() {
        return 352;
    }

    /**
     * Return the value (as a short) of the field 'm2.type'
     */
    public short get_m2_type() {
        return (short)getUIntBEElement(offsetBits_m2_type(), 8);
    }

    /**
     * Set the value of the field 'm2.type'
     */
    public void set_m2_type(short value) {
        setUIntBEElement(offsetBits_m2_type(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm2.type'
     */
    public static int size_m2_type() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm2.type'
     */
    public static int sizeBits_m2_type() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m2.nodeId
    //   Field type: short
    //   Offset (bits): 360
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm2.nodeId' is signed (false).
     */
    public static boolean isSigned_m2_nodeId() {
        return false;
    }

    /**
     * Return whether the field 'm2.nodeId' is an array (false).
     */
    public static boolean isArray_m2_nodeId() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm2.nodeId'
     */
    public static int offset_m2_nodeId() {
        return (360 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm2.nodeId'
     */
    public static int offsetBits_m2_nodeId() {
        return 360;
    }

    /**
     * Return the value (as a short) of the field 'm2.nodeId'
     */
    public short get_m2_nodeId() {
        return (short)getUIntBEElement(offsetBits_m2_nodeId(), 8);
    }

    /**
     * Set the value of the field 'm2.nodeId'
     */
    public void set_m2_nodeId(short value) {
        setUIntBEElement(offsetBits_m2_nodeId(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm2.nodeId'
     */
    public static int size_m2_nodeId() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm2.nodeId'
     */
    public static int sizeBits_m2_nodeId() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m2.sourceId
    //   Field type: short
    //   Offset (bits): 368
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm2.sourceId' is signed (false).
     */
    public static boolean isSigned_m2_sourceId() {
        return false;
    }

    /**
     * Return whether the field 'm2.sourceId' is an array (false).
     */
    public static boolean isArray_m2_sourceId() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm2.sourceId'
     */
    public static int offset_m2_sourceId() {
        return (368 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm2.sourceId'
     */
    public static int offsetBits_m2_sourceId() {
        return 368;
    }

    /**
     * Return the value (as a short) of the field 'm2.sourceId'
     */
    public short get_m2_sourceId() {
        return (short)getUIntBEElement(offsetBits_m2_sourceId(), 8);
    }

    /**
     * Set the value of the field 'm2.sourceId'
     */
    public void set_m2_sourceId(short value) {
        setUIntBEElement(offsetBits_m2_sourceId(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm2.sourceId'
     */
    public static int size_m2_sourceId() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm2.sourceId'
     */
    public static int sizeBits_m2_sourceId() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m2.seq
    //   Field type: int
    //   Offset (bits): 376
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm2.seq' is signed (false).
     */
    public static boolean isSigned_m2_seq() {
        return false;
    }

    /**
     * Return whether the field 'm2.seq' is an array (false).
     */
    public static boolean isArray_m2_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm2.seq'
     */
    public static int offset_m2_seq() {
        return (376 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm2.seq'
     */
    public static int offsetBits_m2_seq() {
        return 376;
    }

    /**
     * Return the value (as a int) of the field 'm2.seq'
     */
    public int get_m2_seq() {
        return (int)getUIntBEElement(offsetBits_m2_seq(), 16);
    }

    /**
     * Set the value of the field 'm2.seq'
     */
    public void set_m2_seq(int value) {
        setUIntBEElement(offsetBits_m2_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm2.seq'
     */
    public static int size_m2_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm2.seq'
     */
    public static int sizeBits_m2_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m2.last_hop
    //   Field type: short
    //   Offset (bits): 392
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm2.last_hop' is signed (false).
     */
    public static boolean isSigned_m2_last_hop() {
        return false;
    }

    /**
     * Return whether the field 'm2.last_hop' is an array (false).
     */
    public static boolean isArray_m2_last_hop() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm2.last_hop'
     */
    public static int offset_m2_last_hop() {
        return (392 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm2.last_hop'
     */
    public static int offsetBits_m2_last_hop() {
        return 392;
    }

    /**
     * Return the value (as a short) of the field 'm2.last_hop'
     */
    public short get_m2_last_hop() {
        return (short)getUIntBEElement(offsetBits_m2_last_hop(), 8);
    }

    /**
     * Set the value of the field 'm2.last_hop'
     */
    public void set_m2_last_hop(short value) {
        setUIntBEElement(offsetBits_m2_last_hop(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm2.last_hop'
     */
    public static int size_m2_last_hop() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm2.last_hop'
     */
    public static int sizeBits_m2_last_hop() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m2.last_hop_ntw_seq
    //   Field type: int
    //   Offset (bits): 400
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm2.last_hop_ntw_seq' is signed (false).
     */
    public static boolean isSigned_m2_last_hop_ntw_seq() {
        return false;
    }

    /**
     * Return whether the field 'm2.last_hop_ntw_seq' is an array (false).
     */
    public static boolean isArray_m2_last_hop_ntw_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm2.last_hop_ntw_seq'
     */
    public static int offset_m2_last_hop_ntw_seq() {
        return (400 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm2.last_hop_ntw_seq'
     */
    public static int offsetBits_m2_last_hop_ntw_seq() {
        return 400;
    }

    /**
     * Return the value (as a int) of the field 'm2.last_hop_ntw_seq'
     */
    public int get_m2_last_hop_ntw_seq() {
        return (int)getUIntBEElement(offsetBits_m2_last_hop_ntw_seq(), 16);
    }

    /**
     * Set the value of the field 'm2.last_hop_ntw_seq'
     */
    public void set_m2_last_hop_ntw_seq(int value) {
        setUIntBEElement(offsetBits_m2_last_hop_ntw_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm2.last_hop_ntw_seq'
     */
    public static int size_m2_last_hop_ntw_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm2.last_hop_ntw_seq'
     */
    public static int sizeBits_m2_last_hop_ntw_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m2.last_hop_seq
    //   Field type: int
    //   Offset (bits): 416
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm2.last_hop_seq' is signed (false).
     */
    public static boolean isSigned_m2_last_hop_seq() {
        return false;
    }

    /**
     * Return whether the field 'm2.last_hop_seq' is an array (false).
     */
    public static boolean isArray_m2_last_hop_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm2.last_hop_seq'
     */
    public static int offset_m2_last_hop_seq() {
        return (416 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm2.last_hop_seq'
     */
    public static int offsetBits_m2_last_hop_seq() {
        return 416;
    }

    /**
     * Return the value (as a int) of the field 'm2.last_hop_seq'
     */
    public int get_m2_last_hop_seq() {
        return (int)getUIntBEElement(offsetBits_m2_last_hop_seq(), 16);
    }

    /**
     * Set the value of the field 'm2.last_hop_seq'
     */
    public void set_m2_last_hop_seq(int value) {
        setUIntBEElement(offsetBits_m2_last_hop_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm2.last_hop_seq'
     */
    public static int size_m2_last_hop_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm2.last_hop_seq'
     */
    public static int sizeBits_m2_last_hop_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m2.local_ntw_seq
    //   Field type: int
    //   Offset (bits): 432
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm2.local_ntw_seq' is signed (false).
     */
    public static boolean isSigned_m2_local_ntw_seq() {
        return false;
    }

    /**
     * Return whether the field 'm2.local_ntw_seq' is an array (false).
     */
    public static boolean isArray_m2_local_ntw_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm2.local_ntw_seq'
     */
    public static int offset_m2_local_ntw_seq() {
        return (432 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm2.local_ntw_seq'
     */
    public static int offsetBits_m2_local_ntw_seq() {
        return 432;
    }

    /**
     * Return the value (as a int) of the field 'm2.local_ntw_seq'
     */
    public int get_m2_local_ntw_seq() {
        return (int)getUIntBEElement(offsetBits_m2_local_ntw_seq(), 16);
    }

    /**
     * Set the value of the field 'm2.local_ntw_seq'
     */
    public void set_m2_local_ntw_seq(int value) {
        setUIntBEElement(offsetBits_m2_local_ntw_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm2.local_ntw_seq'
     */
    public static int size_m2_local_ntw_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm2.local_ntw_seq'
     */
    public static int sizeBits_m2_local_ntw_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m2.local_seq
    //   Field type: int
    //   Offset (bits): 448
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm2.local_seq' is signed (false).
     */
    public static boolean isSigned_m2_local_seq() {
        return false;
    }

    /**
     * Return whether the field 'm2.local_seq' is an array (false).
     */
    public static boolean isArray_m2_local_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm2.local_seq'
     */
    public static int offset_m2_local_seq() {
        return (448 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm2.local_seq'
     */
    public static int offsetBits_m2_local_seq() {
        return 448;
    }

    /**
     * Return the value (as a int) of the field 'm2.local_seq'
     */
    public int get_m2_local_seq() {
        return (int)getUIntBEElement(offsetBits_m2_local_seq(), 16);
    }

    /**
     * Set the value of the field 'm2.local_seq'
     */
    public void set_m2_local_seq(int value) {
        setUIntBEElement(offsetBits_m2_local_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm2.local_seq'
     */
    public static int size_m2_local_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm2.local_seq'
     */
    public static int sizeBits_m2_local_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m2.timestamp
    //   Field type: long
    //   Offset (bits): 464
    //   Size (bits): 32
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm2.timestamp' is signed (false).
     */
    public static boolean isSigned_m2_timestamp() {
        return false;
    }

    /**
     * Return whether the field 'm2.timestamp' is an array (false).
     */
    public static boolean isArray_m2_timestamp() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm2.timestamp'
     */
    public static int offset_m2_timestamp() {
        return (464 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm2.timestamp'
     */
    public static int offsetBits_m2_timestamp() {
        return 464;
    }

    /**
     * Return the value (as a long) of the field 'm2.timestamp'
     */
    public long get_m2_timestamp() {
        return (long)getUIntBEElement(offsetBits_m2_timestamp(), 32);
    }

    /**
     * Set the value of the field 'm2.timestamp'
     */
    public void set_m2_timestamp(long value) {
        setUIntBEElement(offsetBits_m2_timestamp(), 32, value);
    }

    /**
     * Return the size, in bytes, of the field 'm2.timestamp'
     */
    public static int size_m2_timestamp() {
        return (32 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm2.timestamp'
     */
    public static int sizeBits_m2_timestamp() {
        return 32;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m2.seqno
    //   Field type: long
    //   Offset (bits): 496
    //   Size (bits): 32
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm2.seqno' is signed (false).
     */
    public static boolean isSigned_m2_seqno() {
        return false;
    }

    /**
     * Return whether the field 'm2.seqno' is an array (false).
     */
    public static boolean isArray_m2_seqno() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm2.seqno'
     */
    public static int offset_m2_seqno() {
        return (496 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm2.seqno'
     */
    public static int offsetBits_m2_seqno() {
        return 496;
    }

    /**
     * Return the value (as a long) of the field 'm2.seqno'
     */
    public long get_m2_seqno() {
        return (long)getUIntBEElement(offsetBits_m2_seqno(), 32);
    }

    /**
     * Set the value of the field 'm2.seqno'
     */
    public void set_m2_seqno(long value) {
        setUIntBEElement(offsetBits_m2_seqno(), 32, value);
    }

    /**
     * Return the size, in bytes, of the field 'm2.seqno'
     */
    public static int size_m2_seqno() {
        return (32 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm2.seqno'
     */
    public static int sizeBits_m2_seqno() {
        return 32;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m3.type
    //   Field type: short
    //   Offset (bits): 528
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm3.type' is signed (false).
     */
    public static boolean isSigned_m3_type() {
        return false;
    }

    /**
     * Return whether the field 'm3.type' is an array (false).
     */
    public static boolean isArray_m3_type() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm3.type'
     */
    public static int offset_m3_type() {
        return (528 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm3.type'
     */
    public static int offsetBits_m3_type() {
        return 528;
    }

    /**
     * Return the value (as a short) of the field 'm3.type'
     */
    public short get_m3_type() {
        return (short)getUIntBEElement(offsetBits_m3_type(), 8);
    }

    /**
     * Set the value of the field 'm3.type'
     */
    public void set_m3_type(short value) {
        setUIntBEElement(offsetBits_m3_type(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm3.type'
     */
    public static int size_m3_type() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm3.type'
     */
    public static int sizeBits_m3_type() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m3.nodeId
    //   Field type: short
    //   Offset (bits): 536
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm3.nodeId' is signed (false).
     */
    public static boolean isSigned_m3_nodeId() {
        return false;
    }

    /**
     * Return whether the field 'm3.nodeId' is an array (false).
     */
    public static boolean isArray_m3_nodeId() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm3.nodeId'
     */
    public static int offset_m3_nodeId() {
        return (536 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm3.nodeId'
     */
    public static int offsetBits_m3_nodeId() {
        return 536;
    }

    /**
     * Return the value (as a short) of the field 'm3.nodeId'
     */
    public short get_m3_nodeId() {
        return (short)getUIntBEElement(offsetBits_m3_nodeId(), 8);
    }

    /**
     * Set the value of the field 'm3.nodeId'
     */
    public void set_m3_nodeId(short value) {
        setUIntBEElement(offsetBits_m3_nodeId(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm3.nodeId'
     */
    public static int size_m3_nodeId() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm3.nodeId'
     */
    public static int sizeBits_m3_nodeId() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m3.sourceId
    //   Field type: short
    //   Offset (bits): 544
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm3.sourceId' is signed (false).
     */
    public static boolean isSigned_m3_sourceId() {
        return false;
    }

    /**
     * Return whether the field 'm3.sourceId' is an array (false).
     */
    public static boolean isArray_m3_sourceId() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm3.sourceId'
     */
    public static int offset_m3_sourceId() {
        return (544 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm3.sourceId'
     */
    public static int offsetBits_m3_sourceId() {
        return 544;
    }

    /**
     * Return the value (as a short) of the field 'm3.sourceId'
     */
    public short get_m3_sourceId() {
        return (short)getUIntBEElement(offsetBits_m3_sourceId(), 8);
    }

    /**
     * Set the value of the field 'm3.sourceId'
     */
    public void set_m3_sourceId(short value) {
        setUIntBEElement(offsetBits_m3_sourceId(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm3.sourceId'
     */
    public static int size_m3_sourceId() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm3.sourceId'
     */
    public static int sizeBits_m3_sourceId() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m3.seq
    //   Field type: int
    //   Offset (bits): 552
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm3.seq' is signed (false).
     */
    public static boolean isSigned_m3_seq() {
        return false;
    }

    /**
     * Return whether the field 'm3.seq' is an array (false).
     */
    public static boolean isArray_m3_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm3.seq'
     */
    public static int offset_m3_seq() {
        return (552 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm3.seq'
     */
    public static int offsetBits_m3_seq() {
        return 552;
    }

    /**
     * Return the value (as a int) of the field 'm3.seq'
     */
    public int get_m3_seq() {
        return (int)getUIntBEElement(offsetBits_m3_seq(), 16);
    }

    /**
     * Set the value of the field 'm3.seq'
     */
    public void set_m3_seq(int value) {
        setUIntBEElement(offsetBits_m3_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm3.seq'
     */
    public static int size_m3_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm3.seq'
     */
    public static int sizeBits_m3_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m3.last_hop
    //   Field type: short
    //   Offset (bits): 568
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm3.last_hop' is signed (false).
     */
    public static boolean isSigned_m3_last_hop() {
        return false;
    }

    /**
     * Return whether the field 'm3.last_hop' is an array (false).
     */
    public static boolean isArray_m3_last_hop() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm3.last_hop'
     */
    public static int offset_m3_last_hop() {
        return (568 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm3.last_hop'
     */
    public static int offsetBits_m3_last_hop() {
        return 568;
    }

    /**
     * Return the value (as a short) of the field 'm3.last_hop'
     */
    public short get_m3_last_hop() {
        return (short)getUIntBEElement(offsetBits_m3_last_hop(), 8);
    }

    /**
     * Set the value of the field 'm3.last_hop'
     */
    public void set_m3_last_hop(short value) {
        setUIntBEElement(offsetBits_m3_last_hop(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm3.last_hop'
     */
    public static int size_m3_last_hop() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm3.last_hop'
     */
    public static int sizeBits_m3_last_hop() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m3.last_hop_ntw_seq
    //   Field type: int
    //   Offset (bits): 576
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm3.last_hop_ntw_seq' is signed (false).
     */
    public static boolean isSigned_m3_last_hop_ntw_seq() {
        return false;
    }

    /**
     * Return whether the field 'm3.last_hop_ntw_seq' is an array (false).
     */
    public static boolean isArray_m3_last_hop_ntw_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm3.last_hop_ntw_seq'
     */
    public static int offset_m3_last_hop_ntw_seq() {
        return (576 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm3.last_hop_ntw_seq'
     */
    public static int offsetBits_m3_last_hop_ntw_seq() {
        return 576;
    }

    /**
     * Return the value (as a int) of the field 'm3.last_hop_ntw_seq'
     */
    public int get_m3_last_hop_ntw_seq() {
        return (int)getUIntBEElement(offsetBits_m3_last_hop_ntw_seq(), 16);
    }

    /**
     * Set the value of the field 'm3.last_hop_ntw_seq'
     */
    public void set_m3_last_hop_ntw_seq(int value) {
        setUIntBEElement(offsetBits_m3_last_hop_ntw_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm3.last_hop_ntw_seq'
     */
    public static int size_m3_last_hop_ntw_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm3.last_hop_ntw_seq'
     */
    public static int sizeBits_m3_last_hop_ntw_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m3.last_hop_seq
    //   Field type: int
    //   Offset (bits): 592
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm3.last_hop_seq' is signed (false).
     */
    public static boolean isSigned_m3_last_hop_seq() {
        return false;
    }

    /**
     * Return whether the field 'm3.last_hop_seq' is an array (false).
     */
    public static boolean isArray_m3_last_hop_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm3.last_hop_seq'
     */
    public static int offset_m3_last_hop_seq() {
        return (592 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm3.last_hop_seq'
     */
    public static int offsetBits_m3_last_hop_seq() {
        return 592;
    }

    /**
     * Return the value (as a int) of the field 'm3.last_hop_seq'
     */
    public int get_m3_last_hop_seq() {
        return (int)getUIntBEElement(offsetBits_m3_last_hop_seq(), 16);
    }

    /**
     * Set the value of the field 'm3.last_hop_seq'
     */
    public void set_m3_last_hop_seq(int value) {
        setUIntBEElement(offsetBits_m3_last_hop_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm3.last_hop_seq'
     */
    public static int size_m3_last_hop_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm3.last_hop_seq'
     */
    public static int sizeBits_m3_last_hop_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m3.local_ntw_seq
    //   Field type: int
    //   Offset (bits): 608
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm3.local_ntw_seq' is signed (false).
     */
    public static boolean isSigned_m3_local_ntw_seq() {
        return false;
    }

    /**
     * Return whether the field 'm3.local_ntw_seq' is an array (false).
     */
    public static boolean isArray_m3_local_ntw_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm3.local_ntw_seq'
     */
    public static int offset_m3_local_ntw_seq() {
        return (608 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm3.local_ntw_seq'
     */
    public static int offsetBits_m3_local_ntw_seq() {
        return 608;
    }

    /**
     * Return the value (as a int) of the field 'm3.local_ntw_seq'
     */
    public int get_m3_local_ntw_seq() {
        return (int)getUIntBEElement(offsetBits_m3_local_ntw_seq(), 16);
    }

    /**
     * Set the value of the field 'm3.local_ntw_seq'
     */
    public void set_m3_local_ntw_seq(int value) {
        setUIntBEElement(offsetBits_m3_local_ntw_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm3.local_ntw_seq'
     */
    public static int size_m3_local_ntw_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm3.local_ntw_seq'
     */
    public static int sizeBits_m3_local_ntw_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m3.local_seq
    //   Field type: int
    //   Offset (bits): 624
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm3.local_seq' is signed (false).
     */
    public static boolean isSigned_m3_local_seq() {
        return false;
    }

    /**
     * Return whether the field 'm3.local_seq' is an array (false).
     */
    public static boolean isArray_m3_local_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm3.local_seq'
     */
    public static int offset_m3_local_seq() {
        return (624 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm3.local_seq'
     */
    public static int offsetBits_m3_local_seq() {
        return 624;
    }

    /**
     * Return the value (as a int) of the field 'm3.local_seq'
     */
    public int get_m3_local_seq() {
        return (int)getUIntBEElement(offsetBits_m3_local_seq(), 16);
    }

    /**
     * Set the value of the field 'm3.local_seq'
     */
    public void set_m3_local_seq(int value) {
        setUIntBEElement(offsetBits_m3_local_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm3.local_seq'
     */
    public static int size_m3_local_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm3.local_seq'
     */
    public static int sizeBits_m3_local_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m3.timestamp
    //   Field type: long
    //   Offset (bits): 640
    //   Size (bits): 32
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm3.timestamp' is signed (false).
     */
    public static boolean isSigned_m3_timestamp() {
        return false;
    }

    /**
     * Return whether the field 'm3.timestamp' is an array (false).
     */
    public static boolean isArray_m3_timestamp() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm3.timestamp'
     */
    public static int offset_m3_timestamp() {
        return (640 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm3.timestamp'
     */
    public static int offsetBits_m3_timestamp() {
        return 640;
    }

    /**
     * Return the value (as a long) of the field 'm3.timestamp'
     */
    public long get_m3_timestamp() {
        return (long)getUIntBEElement(offsetBits_m3_timestamp(), 32);
    }

    /**
     * Set the value of the field 'm3.timestamp'
     */
    public void set_m3_timestamp(long value) {
        setUIntBEElement(offsetBits_m3_timestamp(), 32, value);
    }

    /**
     * Return the size, in bytes, of the field 'm3.timestamp'
     */
    public static int size_m3_timestamp() {
        return (32 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm3.timestamp'
     */
    public static int sizeBits_m3_timestamp() {
        return 32;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m3.seqno
    //   Field type: long
    //   Offset (bits): 672
    //   Size (bits): 32
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm3.seqno' is signed (false).
     */
    public static boolean isSigned_m3_seqno() {
        return false;
    }

    /**
     * Return whether the field 'm3.seqno' is an array (false).
     */
    public static boolean isArray_m3_seqno() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm3.seqno'
     */
    public static int offset_m3_seqno() {
        return (672 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm3.seqno'
     */
    public static int offsetBits_m3_seqno() {
        return 672;
    }

    /**
     * Return the value (as a long) of the field 'm3.seqno'
     */
    public long get_m3_seqno() {
        return (long)getUIntBEElement(offsetBits_m3_seqno(), 32);
    }

    /**
     * Set the value of the field 'm3.seqno'
     */
    public void set_m3_seqno(long value) {
        setUIntBEElement(offsetBits_m3_seqno(), 32, value);
    }

    /**
     * Return the size, in bytes, of the field 'm3.seqno'
     */
    public static int size_m3_seqno() {
        return (32 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm3.seqno'
     */
    public static int sizeBits_m3_seqno() {
        return 32;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m4.type
    //   Field type: short
    //   Offset (bits): 704
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm4.type' is signed (false).
     */
    public static boolean isSigned_m4_type() {
        return false;
    }

    /**
     * Return whether the field 'm4.type' is an array (false).
     */
    public static boolean isArray_m4_type() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm4.type'
     */
    public static int offset_m4_type() {
        return (704 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm4.type'
     */
    public static int offsetBits_m4_type() {
        return 704;
    }

    /**
     * Return the value (as a short) of the field 'm4.type'
     */
    public short get_m4_type() {
        return (short)getUIntBEElement(offsetBits_m4_type(), 8);
    }

    /**
     * Set the value of the field 'm4.type'
     */
    public void set_m4_type(short value) {
        setUIntBEElement(offsetBits_m4_type(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm4.type'
     */
    public static int size_m4_type() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm4.type'
     */
    public static int sizeBits_m4_type() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m4.nodeId
    //   Field type: short
    //   Offset (bits): 712
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm4.nodeId' is signed (false).
     */
    public static boolean isSigned_m4_nodeId() {
        return false;
    }

    /**
     * Return whether the field 'm4.nodeId' is an array (false).
     */
    public static boolean isArray_m4_nodeId() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm4.nodeId'
     */
    public static int offset_m4_nodeId() {
        return (712 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm4.nodeId'
     */
    public static int offsetBits_m4_nodeId() {
        return 712;
    }

    /**
     * Return the value (as a short) of the field 'm4.nodeId'
     */
    public short get_m4_nodeId() {
        return (short)getUIntBEElement(offsetBits_m4_nodeId(), 8);
    }

    /**
     * Set the value of the field 'm4.nodeId'
     */
    public void set_m4_nodeId(short value) {
        setUIntBEElement(offsetBits_m4_nodeId(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm4.nodeId'
     */
    public static int size_m4_nodeId() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm4.nodeId'
     */
    public static int sizeBits_m4_nodeId() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m4.sourceId
    //   Field type: short
    //   Offset (bits): 720
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm4.sourceId' is signed (false).
     */
    public static boolean isSigned_m4_sourceId() {
        return false;
    }

    /**
     * Return whether the field 'm4.sourceId' is an array (false).
     */
    public static boolean isArray_m4_sourceId() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm4.sourceId'
     */
    public static int offset_m4_sourceId() {
        return (720 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm4.sourceId'
     */
    public static int offsetBits_m4_sourceId() {
        return 720;
    }

    /**
     * Return the value (as a short) of the field 'm4.sourceId'
     */
    public short get_m4_sourceId() {
        return (short)getUIntBEElement(offsetBits_m4_sourceId(), 8);
    }

    /**
     * Set the value of the field 'm4.sourceId'
     */
    public void set_m4_sourceId(short value) {
        setUIntBEElement(offsetBits_m4_sourceId(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm4.sourceId'
     */
    public static int size_m4_sourceId() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm4.sourceId'
     */
    public static int sizeBits_m4_sourceId() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m4.seq
    //   Field type: int
    //   Offset (bits): 728
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm4.seq' is signed (false).
     */
    public static boolean isSigned_m4_seq() {
        return false;
    }

    /**
     * Return whether the field 'm4.seq' is an array (false).
     */
    public static boolean isArray_m4_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm4.seq'
     */
    public static int offset_m4_seq() {
        return (728 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm4.seq'
     */
    public static int offsetBits_m4_seq() {
        return 728;
    }

    /**
     * Return the value (as a int) of the field 'm4.seq'
     */
    public int get_m4_seq() {
        return (int)getUIntBEElement(offsetBits_m4_seq(), 16);
    }

    /**
     * Set the value of the field 'm4.seq'
     */
    public void set_m4_seq(int value) {
        setUIntBEElement(offsetBits_m4_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm4.seq'
     */
    public static int size_m4_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm4.seq'
     */
    public static int sizeBits_m4_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m4.last_hop
    //   Field type: short
    //   Offset (bits): 744
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm4.last_hop' is signed (false).
     */
    public static boolean isSigned_m4_last_hop() {
        return false;
    }

    /**
     * Return whether the field 'm4.last_hop' is an array (false).
     */
    public static boolean isArray_m4_last_hop() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm4.last_hop'
     */
    public static int offset_m4_last_hop() {
        return (744 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm4.last_hop'
     */
    public static int offsetBits_m4_last_hop() {
        return 744;
    }

    /**
     * Return the value (as a short) of the field 'm4.last_hop'
     */
    public short get_m4_last_hop() {
        return (short)getUIntBEElement(offsetBits_m4_last_hop(), 8);
    }

    /**
     * Set the value of the field 'm4.last_hop'
     */
    public void set_m4_last_hop(short value) {
        setUIntBEElement(offsetBits_m4_last_hop(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'm4.last_hop'
     */
    public static int size_m4_last_hop() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm4.last_hop'
     */
    public static int sizeBits_m4_last_hop() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m4.last_hop_ntw_seq
    //   Field type: int
    //   Offset (bits): 752
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm4.last_hop_ntw_seq' is signed (false).
     */
    public static boolean isSigned_m4_last_hop_ntw_seq() {
        return false;
    }

    /**
     * Return whether the field 'm4.last_hop_ntw_seq' is an array (false).
     */
    public static boolean isArray_m4_last_hop_ntw_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm4.last_hop_ntw_seq'
     */
    public static int offset_m4_last_hop_ntw_seq() {
        return (752 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm4.last_hop_ntw_seq'
     */
    public static int offsetBits_m4_last_hop_ntw_seq() {
        return 752;
    }

    /**
     * Return the value (as a int) of the field 'm4.last_hop_ntw_seq'
     */
    public int get_m4_last_hop_ntw_seq() {
        return (int)getUIntBEElement(offsetBits_m4_last_hop_ntw_seq(), 16);
    }

    /**
     * Set the value of the field 'm4.last_hop_ntw_seq'
     */
    public void set_m4_last_hop_ntw_seq(int value) {
        setUIntBEElement(offsetBits_m4_last_hop_ntw_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm4.last_hop_ntw_seq'
     */
    public static int size_m4_last_hop_ntw_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm4.last_hop_ntw_seq'
     */
    public static int sizeBits_m4_last_hop_ntw_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m4.last_hop_seq
    //   Field type: int
    //   Offset (bits): 768
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm4.last_hop_seq' is signed (false).
     */
    public static boolean isSigned_m4_last_hop_seq() {
        return false;
    }

    /**
     * Return whether the field 'm4.last_hop_seq' is an array (false).
     */
    public static boolean isArray_m4_last_hop_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm4.last_hop_seq'
     */
    public static int offset_m4_last_hop_seq() {
        return (768 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm4.last_hop_seq'
     */
    public static int offsetBits_m4_last_hop_seq() {
        return 768;
    }

    /**
     * Return the value (as a int) of the field 'm4.last_hop_seq'
     */
    public int get_m4_last_hop_seq() {
        return (int)getUIntBEElement(offsetBits_m4_last_hop_seq(), 16);
    }

    /**
     * Set the value of the field 'm4.last_hop_seq'
     */
    public void set_m4_last_hop_seq(int value) {
        setUIntBEElement(offsetBits_m4_last_hop_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm4.last_hop_seq'
     */
    public static int size_m4_last_hop_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm4.last_hop_seq'
     */
    public static int sizeBits_m4_last_hop_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m4.local_ntw_seq
    //   Field type: int
    //   Offset (bits): 784
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm4.local_ntw_seq' is signed (false).
     */
    public static boolean isSigned_m4_local_ntw_seq() {
        return false;
    }

    /**
     * Return whether the field 'm4.local_ntw_seq' is an array (false).
     */
    public static boolean isArray_m4_local_ntw_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm4.local_ntw_seq'
     */
    public static int offset_m4_local_ntw_seq() {
        return (784 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm4.local_ntw_seq'
     */
    public static int offsetBits_m4_local_ntw_seq() {
        return 784;
    }

    /**
     * Return the value (as a int) of the field 'm4.local_ntw_seq'
     */
    public int get_m4_local_ntw_seq() {
        return (int)getUIntBEElement(offsetBits_m4_local_ntw_seq(), 16);
    }

    /**
     * Set the value of the field 'm4.local_ntw_seq'
     */
    public void set_m4_local_ntw_seq(int value) {
        setUIntBEElement(offsetBits_m4_local_ntw_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm4.local_ntw_seq'
     */
    public static int size_m4_local_ntw_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm4.local_ntw_seq'
     */
    public static int sizeBits_m4_local_ntw_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m4.local_seq
    //   Field type: int
    //   Offset (bits): 800
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm4.local_seq' is signed (false).
     */
    public static boolean isSigned_m4_local_seq() {
        return false;
    }

    /**
     * Return whether the field 'm4.local_seq' is an array (false).
     */
    public static boolean isArray_m4_local_seq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm4.local_seq'
     */
    public static int offset_m4_local_seq() {
        return (800 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm4.local_seq'
     */
    public static int offsetBits_m4_local_seq() {
        return 800;
    }

    /**
     * Return the value (as a int) of the field 'm4.local_seq'
     */
    public int get_m4_local_seq() {
        return (int)getUIntBEElement(offsetBits_m4_local_seq(), 16);
    }

    /**
     * Set the value of the field 'm4.local_seq'
     */
    public void set_m4_local_seq(int value) {
        setUIntBEElement(offsetBits_m4_local_seq(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'm4.local_seq'
     */
    public static int size_m4_local_seq() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm4.local_seq'
     */
    public static int sizeBits_m4_local_seq() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m4.timestamp
    //   Field type: long
    //   Offset (bits): 816
    //   Size (bits): 32
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm4.timestamp' is signed (false).
     */
    public static boolean isSigned_m4_timestamp() {
        return false;
    }

    /**
     * Return whether the field 'm4.timestamp' is an array (false).
     */
    public static boolean isArray_m4_timestamp() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm4.timestamp'
     */
    public static int offset_m4_timestamp() {
        return (816 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm4.timestamp'
     */
    public static int offsetBits_m4_timestamp() {
        return 816;
    }

    /**
     * Return the value (as a long) of the field 'm4.timestamp'
     */
    public long get_m4_timestamp() {
        return (long)getUIntBEElement(offsetBits_m4_timestamp(), 32);
    }

    /**
     * Set the value of the field 'm4.timestamp'
     */
    public void set_m4_timestamp(long value) {
        setUIntBEElement(offsetBits_m4_timestamp(), 32, value);
    }

    /**
     * Return the size, in bytes, of the field 'm4.timestamp'
     */
    public static int size_m4_timestamp() {
        return (32 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm4.timestamp'
     */
    public static int sizeBits_m4_timestamp() {
        return 32;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: m4.seqno
    //   Field type: long
    //   Offset (bits): 848
    //   Size (bits): 32
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'm4.seqno' is signed (false).
     */
    public static boolean isSigned_m4_seqno() {
        return false;
    }

    /**
     * Return whether the field 'm4.seqno' is an array (false).
     */
    public static boolean isArray_m4_seqno() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'm4.seqno'
     */
    public static int offset_m4_seqno() {
        return (848 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'm4.seqno'
     */
    public static int offsetBits_m4_seqno() {
        return 848;
    }

    /**
     * Return the value (as a long) of the field 'm4.seqno'
     */
    public long get_m4_seqno() {
        return (long)getUIntBEElement(offsetBits_m4_seqno(), 32);
    }

    /**
     * Set the value of the field 'm4.seqno'
     */
    public void set_m4_seqno(long value) {
        setUIntBEElement(offsetBits_m4_seqno(), 32, value);
    }

    /**
     * Return the size, in bytes, of the field 'm4.seqno'
     */
    public static int size_m4_seqno() {
        return (32 / 8);
    }

    /**
     * Return the size, in bits, of the field 'm4.seqno'
     */
    public static int sizeBits_m4_seqno() {
        return 32;
    }

}
